
:host {
   display: grid;
   grid-template:
      "content     content content  content      content" 1fr
      "seek        seek    seek     seek         seek"
      "left-gutter time    controls right-gutter right-gutter"
      /
      1fr 10ch auto 10ch 1fr
   ;
   
   /* Guide the aspect ratio of the video player. */
   --aspect-ratio: auto;
   
   --focus-border-image: url(focus-border-image.svg) 4 3 3 4/auto repeat;
   --focus-outline:      none;
   
   --min-video-width:  0;
   --min-video-height: 0;
   --max-video-width:  100%;
   --max-video-height: none;
   
   /* Scale the player UI. */
   --scale: 1;
}

:host(.theater) {
   .content {
      grid-row: 1 / span 100;
   }
   .seek {
      margin-left: calc(12px * var(--scale,1));
      margin-right: calc(12px * var(--scale,1));
   }
   .controls {
      border: 0 solid transparent;
      border-width: calc(8px * var(--scale,1)) 0;
      
      --background: #FFFFFF60;
   }
}

/*
   General element styles:
*/

wm-slider {
   position: relative;
   &:focus-visible {
      outline: none;
      &::before {
         position: absolute;
         content: " ";
         inset:   0;
         z-index: 20;
         border-image: var(--focus-border-image, none);
         border-image-outset: 3px;
         outline:      var(--focus-outline);
      }
   }
}

/*
   Layout
*/

.content {
   grid-area:  content;
   max-width:  100%;
   min-height: 0px; /* allow this grid region to shrink if the player container shrinks */
   
   background: #000;
   
   display: grid;
   grid-template: "video";
   justify-items: center;
   align-items: center;
}
video {
   min-width:  var(--min-video-width, 0);
   min-height: var(--min-video-height, 0);
   max-width:  var(--max-video-width, 100%);
   max-height: var(--max-video-height, none);
   
   aspect-ratio: var(--aspect-ratio, auto);
   object-fit:   contain;
   
   /* ensure we shrink to fit the player when necessary */
   width:  100%;
   height: 100%;
}

.seek {
   grid-area: seek;
   margin: calc(2px * var(--scale,1)) 0;
}
:host(:state(buffering)) .seek {
   --fill-gradient: linear-gradient(to bottom, #a7c2d3, #3c587f, #90a7c5);
}
:host(:state(stalled)) .seek {
   --fill-gradient: linear-gradient(to bottom, #e2adad, #933434, #d28080);
}

.current-time {
   grid-area:  time;
   align-self: center;
   padding-right: .3em;
   
   text-align: right;
   
   font-family: "Segoe UI", Arial, sans-serif;
   color: #000;
   -webkit-text-stroke: 4px #FFF; /* TODO: this is for a light background only */
   paint-order: stroke fill;
   
   user-select: none;
}
:host(.theater) .current-time {
   color: #FFF;
   -webkit-text-stroke: 4px #000A;
}

.controls {
   --background: transparent;
   
   --padding: calc(5px * var(--scale,1));
   --height:  calc(23px * var(--scale,1));
   
   --base-widget-gap: calc(6px * var(--scale,1));
   --endcap-padding:  calc(18px * var(--scale,1));
   
   --border-thickness: calc(1px * var(--scale,1));
   
   --play-pause-button-region: calc(50px * var(--scale,1));
   --play-pause-button-hitbox: calc(43px * var(--scale,1));
   
   --extra-height: calc(var(--play-pause-button-hitbox) + (var(--padding) + var(--border-thickness)) * 2);
   --extra-diff:   calc((var(--extra-height) - var(--height)) / 2);
   
   /*
      Setting border-radius to 50% creates an ellipse, whereas what we want 
      is a capsule. Setting an arbitrary huge value gives us a capsule.
   */
   --really-huge-value: 800px;
   
   grid-area: controls;
   
   display: grid;
   grid-template: "left play right" var(--height) / min-content var(--play-pause-button-hitbox) min-content;
   justify-content: center;
   align-items: center;
   
   margin: var(--extra-diff) 0;
   
   /*
      We want an outline wrapping the player controls, hugging them tightly: 
      think of a horizontal capsule where, at the center, it bulges in a 
      circular shape around the play/pause button.
      
      The easiest way to do this is:
      
       - Split the controls around the play/pause button into "left" and 
         "right" halves.
         
       - Put borders on those halves.
       
       - Overlay the play/pause button with a circular element that has a 
         border, and use clip paths to slice off the middle portions.
   */
   & .left,
   & .right {
      display:   flex;
      flex-flow: row nowrap;
      justify-content: center;
      align-items: center;
      gap: var(--base-widget-gap);
      
      padding: var(--padding) 0;
      height:  var(--height);
      
      border: var(--border-thickness) solid #A8A8A9;
      border-top-color: #A8A8A9;
      border-bottom-color: #CECDCF;
      border-radius: var(--really-huge-value);
      
      background: var(--background);
   }
   & .left {
      grid-area: left;
      padding-left: calc(var(--endcap-padding) + 4px*var(--scale,1));
      border-radius: var(--really-huge-value) 0 0 var(--really-huge-value);
      border-right-width: 0;
   }
   & .right {
      grid-area: right;
      padding-right: var(--endcap-padding);
      border-radius: 0 var(--really-huge-value) var(--really-huge-value) 0;
      border-left-width: 0;
   }
   &::before {
      content: " ";
      grid-area: play;
      justify-self: center;
      pointer-events: none;
      
      --extent:       calc(var(--play-pause-button-hitbox) + (var(--padding) + var(--border-thickness))*2);
      --area-to-show: calc(11px * var(--scale,1));
      
      width:   var(--play-pause-button-hitbox);
      height:  var(--play-pause-button-hitbox);
      padding: var(--padding);
      
      border: var(--border-thickness) solid #A8A8A9;
      border-top-color: #A8A8A9;
      border-bottom-color: #CECDCF;
      border-radius: 50%;
      
      background: var(--background);
      
      mask:
         linear-gradient(
            to bottom,
            #FFF 0px,
            #FFF var(--area-to-show),
            #000 var(--area-to-show),
            #000 calc(var(--extent) - var(--area-to-show)),
            #FFF calc(var(--extent) - var(--area-to-show)),
            #FFF var(--extent)
         ) luminance 0 0/var(--extent) var(--extent) no-repeat,
         linear-gradient(
            to bottom,
            #FFF 0%,
            #FFF 100%
         ) luminance calc((var(--padding) + 1px)*var(--scale,1)) calc(5px*var(--scale,1))/var(--play-pause-button-hitbox) calc(39px*var(--scale,1)) no-repeat
      ;
   }
}

.controls hr {
   width:  0;
   height: 100%;
   margin: 0 .25em;
   border: 0 solid #CECDCF;
   border-left-width: 1px;
   border-right-width: 1px;
}

/* Set up helper variables/expressions for the button and glyph sprites. */
:where(.controls :is(button, .basic-button)) {
   /*
      BUTTON SPRITE CONFIGURATION
      
      The assumption is that buttons will be designed in a horizontal spritesheet, 
      where the first four sprites are Normal, Hover, Active, and Disabled. You can 
      optionally define additional sprites and override `--button-sprite-count`.
      
      You must define the following variables:
      
         --button-spritesheet
         
            A CSS URL (i.e. `url(...)`) for the spritesheet.
      
         --button-original-width
         --button-original-height
         
            The in-SVG size of an individual button sprite. Use the px unit.
            
         --button-original-scale
         
            The scaling factor at which the buttons were designed. For example, if 
            WMP at 1x scale uses a 50px button but your button sprites are 100px, 
            then this variable would be 2.
   */
   
   --button-sprite-count: 4;
   
   --use-button-scale: calc(var(--scale,1) / var(--button-original-scale));
   --use-button-w:     calc(var(--button-original-width)  * var(--use-button-scale));
   
   --button-sprite-normal:   0;
   --button-sprite-hover:    1;
   --button-sprite-active:   2;
   --button-sprite-disabled: 3;
   
   --button-background:
      var(--button-spritesheet)
      /*pos-x*/  calc(-1 * var(--use-button-sprite) * var(--use-button-w))
      /*pos-y*/  0
      /
      /*width*/  calc(var(--button-sprite-count) * var(--use-button-w))
      /*height*/ calc(var(--button-original-height) * var(--use-button-scale))
      no-repeat
   ;
   
   /* INPUTS */
   
   /* override as appropriate. */
   --use-button-sprite: var(--button-sprite-normal);
   
   /* defaults for element states */
   &:hover {
      --use-button-sprite: var(--button-sprite-hover);
   }
   &:active {
      --use-button-sprite: var(--button-sprite-active);
   }
   &:disabled {
      --use-button-sprite: var(--button-sprite-disabled);
   }
   
   /*
      BUTTON LABEL GLYPH CONFIGURATION
      
      You must define the following variables:
      
         --glyph-original-width
         --glyph-original-height
         
            The in-SVG size of an individual glyph sprite. Use the px unit.
            
         --glyph-original-scale
         
            The scaling factor at which the glyphs were designed. For example, if 
            WMP at 1x scale uses a 50px glyph but your glyph sprites are 100px, 
            then this variable would be 2.
            
         --glyph-spritesheet-rows
         --glyph-spritesheet-cols
         
            The number of rows and columns in the spritesheet.
   */
   
   /* offset of the glyph from the button sprite */
   --glyph-x: 0px;
   --glyph-y: 0px;
   
   --use-glyph-scale: calc(var(--scale,1) / var(--glyph-original-scale));
   --use-glyph-w:     calc(var(--glyph-original-width)  * var(--use-glyph-scale));
   --use-glyph-h:     calc(var(--glyph-original-height) * var(--use-glyph-scale));
   
   /* override as appropriate for each element state. */
   --use-glyph-row: 0;
   --use-glyph-col: 0;
   
   --glyph-background:
      var(--glyph-spritesheet)
      /*pos-x*/  calc(var(--glyph-x) - var(--use-glyph-col) * var(--use-glyph-w))
      /*pos-y*/  calc(var(--glyph-y) - var(--use-glyph-row) * var(--use-glyph-h))
      /
      /*width*/  calc(var(--glyph-spritesheet-cols) * var(--use-glyph-w))
      /*height*/ calc(var(--glyph-spritesheet-rows) * var(--use-glyph-h))
      no-repeat
   ;
}

/*
   Square-shaped buttons, whose glyphs are always visible but whose glassy 
   buttons only appear on hover.
   
   In general, most of our buttons have graphics that are larger than their 
   hitboxes (due to shadows, glows, and so on). For these square buttons, 
   we give the button a size that matches the hitbox, and attach the actual 
   graphics to a pseudo-element. Buttons with unusual shapes are harder.
*/
.basic-button {
   all: unset;
   appearance: none;
   user-select: none;
   color:  transparent;
   width:  var(--height);
   height: var(--height);
   
   --sprite-w: calc(29px * var(--scale,1));
   --sprite-h: calc(30px * var(--scale,1));
   --sprite-x: calc(-4px * var(--scale,1));
   --sprite-y: calc(-2px * var(--scale,1));
   
   /*
      BUTTON SPRITE CONFIGURATION
   */
   
   --button-spritesheet:     url(spritesheet-generic.svg);
   --button-original-width:  58px;
   --button-original-height: 60px;
   --button-original-scale:  2; /* the button sprites were designed at 2x scale */
   
   /*
      BUTTON LABEL GLYPH CONFIGURATION
   */
   
   --glyph-x: calc(3px  * var(--scale,1));
   --glyph-y: calc(1px  * var(--scale,1));
   
   --glyph-spritesheet:      url(spritesheet-glyphs-general.svg);
   --glyph-original-width:   50px;
   --glyph-original-height:  50px;
   --glyph-original-scale:   2; /* the glyph sprites were designed at 2x scale */
   --glyph-spritesheet-rows: 4;
   --glyph-spritesheet-cols: 5;
   
   /* what rows represent what glyphs */
   --glyph-row-loop:    0;
   --glyph-row-shuffle: 1;
   --glyph-row-stop:    2;
   --glyph-row-volume:  3;
   
   /* what columns represent what variants */
   --glyph-col-off:      0;
   --glyph-col-on:       1;
   --glyph-col-enabled:  0;
   --glyph-col-disabled: 1;
   
   /* settings for specific buttons */
   --use-glyph-row: -1;
   --use-glyph-col: -1;
   
   position: relative;
   
   &::before {
      pointer-events: none;
      content:  " ";
      display:  block;
      width:    var(--sprite-w);
      height:   var(--sprite-h);
      position: absolute;
      left:     var(--sprite-x);
      top:      var(--sprite-y);
      
      background: var(--glyph-background), var(--button-background);
   }
   
   /* focus border; use a pseudo-element to get it in front of the sprite */
   &:focus-visible::after {
      content: " ";
      position: absolute;
      inset:   0;
      border-image: var(--focus-border-image, none);
      outline:      var(--focus-outline);
   }
}
:host(.theater) .basic-button {
   --glyph-spritesheet: url(spritesheet-glyphs-general.svg#theater);
}
.basic-button.shuffle {
   --use-glyph-row: var(--glyph-row-shuffle);
   --use-glyph-col: var(--glyph-col-off);
   &:checked {
      --use-glyph-col: var(--glyph-col-on);
   }
}
.basic-button.loop {
   --use-glyph-row: var(--glyph-row-loop);
   --use-glyph-col: var(--glyph-col-off);
   &:checked {
      --use-glyph-col: var(--glyph-col-on);
   }
}
button.stop {
   --use-glyph-row: var(--glyph-row-stop);
   --use-glyph-col: var(--glyph-col-enabled);
   &:disabled {
      --use-glyph-col: var(--glyph-col-disabled);
   }
}
.basic-button.mute {
   --use-glyph-row: var(--glyph-row-volume);
   --use-glyph-col: 3;
   &[data-glyph="empty"] {
      --use-glyph-col: 0;
   }
   &[data-glyph="low"] {
      --use-glyph-col: 1;
   }
   &[data-glyph="medium"] {
      --use-glyph-col: 2;
   }
   &[data-glyph="high"] {
      --use-glyph-col: 3;
   }
   &:checked {
      --use-glyph-col: 4;
   }
}

/*
   The "previous" and "next" buttons. The former is just the latter rotated 
   by 180 degrees.
   
   These buttons have an unusual hitbox shape -- something that's only really 
   possible using a clip-path. However, a clip-path would also clip the sprite 
   we display via a pseudo-element. Therefore, the button needs to have a zero 
   size in one dimension or the other, with the hitbox attached to a second 
   pseudo-element. (Theoretically in the future, we could set pointer-events 
   to `none` on the button, and then set it to `all` on the pseudo-element; 
   but today, the latter doesn't work outside of SVG in all browsers.)
   
   In practice, we set the width to the button's physical size, and set the 
   height to zero. Of course, this button exists inside of a flex container 
   that wants to center its contents on the cross axis, so we use a margin to 
   add cross-axis size without actually inflating the hitbox.
*/
.prev-rw,
.next-ff {
   all: unset;
   appearance: none;
   user-select: none;
   color: transparent;
   
   --sprite-w: calc(56px * var(--scale,1));
   --sprite-h: calc(35px * var(--scale,1));
   
   --hitbox-w: calc(50px * var(--scale,1));
   --hitbox-h: calc(23px * var(--scale,1));
   --hitbox-x: calc(2px * var(--scale,1));
   --hitbox-y: calc(6px * var(--scale,1));
   
   width:    var(--hitbox-w);
   height:   0;
   margin:   0 0 var(--hitbox-h);
   position: relative;
   
   &::before,
   &::after {
      content:  " ";
      display:  block;
      position: absolute;
      left:     0;
      top:      0;
   }
   
   /*
      BUTTON SPRITE CONFIGURATION
   */
   
   --button-spritesheet:     url(spritesheet-next.svg);
   --button-original-width:  112px;
   --button-original-height: 70px;
   --button-original-scale:  2; /* the button sprites were designed at 2x scale */
   
   /*
      BUTTON LABEL GLYPH CONFIGURATION
   */
   
   --glyph-spritesheet:      url(spritesheet-glyphs-next.svg);
   --glyph-original-width:   112px;
   --glyph-original-height:  70px;
   --glyph-original-scale:   2; /* the glyph sprites were designed at 2x scale */
   --glyph-spritesheet-rows: 2;
   --glyph-spritesheet-cols: 2;
   
   /* what rows represent what glyphs */
   --glyph-row-primary:   1;
   --glyph-row-secondary: 0;
   
   /* what columns represent what variants */
   --glyph-col-enabled:  0;
   --glyph-col-disabled: 1;
   
   /* settings for specific buttons */
   --use-glyph-row: var(--glyph-row-primary);
   --use-glyph-col: var(--glyph-col-enabled);
   
   &:disabled {
      --use-glyph-col: var(--glyph-col-disabled);
   }
   
   &::before { /* visuals */
      pointer-events: none;
      width:   var(--sprite-w);
      height:  var(--sprite-h);
      
      top: calc(-6px * var(--scale,1));
      
      background: var(--glyph-background), var(--button-background);
   }
   &::after { /* hitbox */
      /* can't use CSS variables in a path(), so scale the whole hitbox instead. */
      
      left:   var(--hitbox-x);
      width:  49px;
      height: 25px;
      
      clip-path: path("M 2 0 l 39.5 0 q 7.5 0 7.5 11.5 q 0 11.5 -7.5 11.5 l -39 0 q -1.5 0 -1.5 -1 C 1 21 3 18.5 3 11.5 c 0 -7 -2 -9.5 -2 -10.5 Q 1 0 2.5 0 z");
      transform: scale(var(--scale, 1));
      transform-origin: left top;
   }
   
   &.fast-forward,
   &.can-only-fast-forward,
   &.rewind,
   &.can-only-rewind {
      --use-glyph-row: var(--glyph-row-secondary);
   }
   
   &:focus-visible::before {
      border-image: var(--focus-border-image, none);
      outline:      var(--focus-outline);
   }
}
:host(.theater) :is(.next-ff, .prev-rw) {
   --glyph-spritesheet: url(spritesheet-glyphs-next.svg#theater);
}
.next-ff {
   margin-right: calc(3px * var(--scale,1));
}
.prev-rw {
   margin-left:  calc(3px * var(--scale,1));
}
.prev-rw {
   transform-box:    content-box;
   transform-origin: center center;
   transform:        scale(-100%, 100%);
}

/*
   The play/pause button separates its hitbox from its visuals using the same 
   tricks as the "previous" and "next" buttons.
*/
.play-pause {
   all: unset;
   appearance: none;
   user-select: none;
   color: transparent;
   
   grid-area: play;
   justify-self: center;
   
   width:     var(--play-pause-button-region);
   height:    0;
   margin:    0 0 calc(51px * var(--scale,1)) 0;
   font-size: 0;
   position:  relative;
   
   &::before,
   &::after {
      content:  " ";
      display:  block;
      position: absolute;
      left:     0;
      top:      0;
   }
   
   /*
      BUTTON SPRITE CONFIGURATION
   */
   
   --button-spritesheet:     url(spritesheet-jewel.svg);
   --button-original-width:  100px;
   --button-original-height: 100px;
   --button-original-scale:  2; /* the button sprites were designed at 2x scale */
   
   /*
      BUTTON LABEL GLYPH CONFIGURATION
   */
   
   --glyph-spritesheet:      url(spritesheet-glyphs-play-pause.svg);
   --glyph-original-width:   100px;
   --glyph-original-height:  100px;
   --glyph-original-scale:   2; /* the glyph sprites were designed at 2x scale */
   --glyph-spritesheet-rows: 1;
   --glyph-spritesheet-cols: 2;
   
   --use-glyph-row: 0;
   --use-glyph-col: 0;
   
   &::before { /* visuals */
      pointer-events: none;
      width:  var(--play-pause-button-region);
      height: var(--play-pause-button-region);
      
      background: var(--glyph-background), var(--button-background);
   }
   &::after { /* hitbox */
      --radius: calc(var(--play-pause-button-hitbox) / 2);
   
      width:     var(--play-pause-button-region);
      height:    var(--play-pause-button-region);
      clip-path: ellipse(var(--radius) var(--radius) at center center);
   }
   
   &:focus-visible::before {
      border-image: var(--focus-border-image, none);
      outline:      var(--focus-outline);
   }
}
:host(:state(playing)) .play-pause {
   --use-glyph-col: 1;
}

.volume {
   width: calc(67px * var(--scale,1));
   height: calc(30px * var(--scale,1));
   margin-left: calc(4px * var(--scale,1));
}