
:host {
   display: grid;
   grid-template:
      "content" 1fr
      "seek"
      "controls"
   ;
   
   --scale: 1;
}

:host(.theater) {
   video {
      grid-row: 1 / span 100;
   }
   .seek {
      margin-left: calc(12px * var(--scale,1));
      margin-right: calc(12px * var(--scale,1));
   }
   .controls {
      border: 0 solid transparent;
      border-width: calc(8px * var(--scale,1)) 0;
      
      --background: #FFFFFF60;
   }
}

video {
   grid-area: content;
   max-width: 100%;
}

.seek {
   grid-area: seek;
   margin: calc(2px * var(--scale,1)) 0;
}
:host(:state(buffering)) .seek {
   --fill-gradient: linear-gradient(to bottom, #a7c2d3, #3c587f, #90a7c5);
}
:host(:state(stalled)) .seek {
   --fill-gradient: linear-gradient(to bottom, #e2adad, #933434, #d28080);
}

.controls {
   --background: transparent;
   
   --padding: calc(5px * var(--scale,1));
   --height:  calc(23px * var(--scale,1));
   
   --base-widget-gap: calc(6px * var(--scale,1));
   --endcap-padding:  calc(18px * var(--scale,1));
   
   --border-thickness: calc(1px * var(--scale,1));
   
   --play-pause-button-region: calc(50px * var(--scale,1));
   --play-pause-button-hitbox: calc(43px * var(--scale,1));
   
   --extra-height: calc(var(--play-pause-button-hitbox) + (var(--padding) + var(--border-thickness)) * 2);
   --extra-diff:   calc((var(--extra-height) - var(--height)) / 2);
   
   /*
      Setting border-radius to 50% creates an ellipse, whereas what we want 
      is a capsule. Setting an arbitrary huge value gives us a capsule.
   */
   --really-huge-value: 800px;
   
   grid-area: controls;
   
   display: grid;
   grid-template: "left play right" var(--height) / min-content var(--play-pause-button-hitbox) min-content;
   justify-content: center;
   align-items: center;
   
   margin: var(--extra-diff) 0;
   
   /*
      We want an outline wrapping the player controls, hugging them tightly: 
      think of a horizontal capsule where, at the center, it bulges in a 
      circular shape around the play/pause button.
      
      The easiest way to do this is:
      
       - Split the controls around the play/pause button into "left" and 
         "right" halves.
         
       - Put borders on those halves.
       
       - Overlay the play/pause button with a circular element that has a 
         border, and use clip paths to slice off the middle portions.
   */
   & .left,
   & .right {
      display:   flex;
      flex-flow: row nowrap;
      justify-content: center;
      align-items: center;
      gap: var(--base-widget-gap);
      
      padding: var(--padding) 0;
      height:  var(--height);
      
      border: var(--border-thickness) solid #A8A8A9;
      border-top-color: #A8A8A9;
      border-bottom-color: #CECDCF;
      border-radius: var(--really-huge-value);
      
      background: var(--background);
   }
   & .left {
      grid-area: left;
      padding-left: calc(var(--endcap-padding) + 4px*var(--scale,1));
      border-radius: var(--really-huge-value) 0 0 var(--really-huge-value);
      border-right-width: 0;
   }
   & .right {
      grid-area: right;
      padding-right: var(--endcap-padding);
      border-radius: 0 var(--really-huge-value) var(--really-huge-value) 0;
      border-left-width: 0;
   }
   &::before {
      content: " ";
      grid-area: play;
      justify-self: center;
      pointer-events: none;
      
      --extent:       calc(var(--play-pause-button-hitbox) + (var(--padding) + var(--border-thickness))*2);
      --area-to-show: calc(11px*var(--scale,1));
      
      width:   var(--play-pause-button-hitbox);
      height:  var(--play-pause-button-hitbox);
      padding: var(--padding);
      
      border: var(--border-thickness) solid #A8A8A9;
      border-top-color: #A8A8A9;
      border-bottom-color: #CECDCF;
      border-radius: 50%;
      
      background: var(--background);
      
      mask:
         linear-gradient(
            to bottom,
            #FFF 0px,
            #FFF var(--area-to-show),
            #000 var(--area-to-show),
            #000 calc(var(--extent) - var(--area-to-show)),
            #FFF calc(var(--extent) - var(--area-to-show)),
            #FFF var(--extent)
         ) luminance 0 0/var(--extent) var(--extent) no-repeat,
         linear-gradient(
            to bottom,
            #FFF 0%,
            #FFF 100%
         ) luminance 6px 5px/43px 39px no-repeat
      ;
   }
}

.controls hr {
   width:  0;
   height: 100%;
   margin: 0 .25em;
   border: 0 solid #CECDCF;
   border-left-width: 1px;
   border-right-width: 1px;
}

/*
   Square-shaped buttons, whose glyphs are always visible but whose glassy 
   buttons only appear on hover.
   
   In general, most of our buttons have graphics that are larger than their 
   hitboxes (due to shadows, glows, and so on). For these square buttons, 
   we give the button a size that matches the hitbox, and attach the actual 
   graphics to a pseudo-element. Buttons with unusual shapes are harder.
*/
.basic-button {
   all: unset;
   appearance: none;
   user-select: none;
   color:  transparent;
   width:  var(--height);
   height: var(--height);
   
   --sprite-w: calc(29px * var(--scale,1));
   --sprite-h: calc(30px * var(--scale,1));
   --sprite-x: calc(-4px * var(--scale,1));
   --sprite-y: calc(-2px * var(--scale,1));
   
   --sprite: url(spritesheet-generic.svg#normal);
   --glyph:  linear-gradient(to bottom, transparent, transparent); /* dummy "no glyph" value */
   
   &:hover {
      --sprite: url(spritesheet-generic.svg#hover);
   }
   &:active {
      --sprite: url(spritesheet-generic.svg#active);
   }
   &:disabled {
      --sprite: url(spritesheet-generic.svg#disabled);
   }
   
   position: relative;
   
   &::before {
      pointer-events: none;
      content:  " ";
      display:  block;
      width:    var(--sprite-w);
      height:   var(--sprite-h);
      position: absolute;
      left:     var(--sprite-x);
      top:      var(--sprite-y);
      
      background:
         var(--glyph)  left top/var(--sprite-w) var(--sprite-h) no-repeat,
         var(--sprite) left top/var(--sprite-w) var(--sprite-h) no-repeat
      ;
   }
}

/*
   The "previous" and "next" buttons. The former is just the latter rotated 
   by 180 degrees.
   
   These buttons have an unusual hitbox shape -- something that's only really 
   possible using a clip-path. However, a clip-path would also clip the sprite 
   we display via a pseudo-element. Therefore, the button needs to have a zero 
   size in one dimension or the other, with the hitbox attached to a second 
   pseudo-element. (Theoretically in the future, we could set pointer-events 
   to `none` on the button, and then set it to `all` on the pseudo-element; 
   but today, the latter doesn't work outside of SVG in all browsers.)
   
   In practice, we set the width to the button's physical size, and set the 
   height to zero. Of course, this button exists inside of a flex container 
   that wants to center its contents on the cross axis, so we use a margin to 
   add cross-axis size without actually inflating the hitbox.
*/
.prev-rw,
.next-ff {
   all: unset;
   appearance: none;
   user-select: none;
   color: transparent;
   
   --sprite-w: calc(56px * var(--scale,1));
   --sprite-h: calc(35px * var(--scale,1));
   
   --hitbox-w: calc(50px * var(--scale,1));
   --hitbox-h: calc(23px * var(--scale,1));
   --hitbox-x: calc(2px * var(--scale,1));
   --hitbox-y: calc(6px * var(--scale,1));
   
   width:    var(--hitbox-w);
   height:   0;
   margin:   0 0 var(--hitbox-h);
   position: relative;
   
   &::before,
   &::after {
      content:  " ";
      display:  block;
      position: absolute;
      left:     0;
      top:      0;
   }
   
   --sprite: url(spritesheet-next.svg#normal-next);
   &:hover {
      --sprite: url(spritesheet-next.svg#hover-next);
   }
   &:active {
      --sprite: url(spritesheet-next.svg#active-next);
   }
   &:disabled {
      --sprite: url(spritesheet-next.svg#disabled-next);
   }
   
   &::before { /* visuals */
      pointer-events: none;
      width:   var(--sprite-w);
      height:  var(--sprite-h);
      
      top: calc(-6px * var(--scale,1));
      
      background: var(--sprite) left top/var(--sprite-w) var(--sprite-h) no-repeat;
   }
   &::after { /* hitbox */
      /* can't use CSS variables in a path(), so scale the whole hitbox instead. */
      
      left:   var(--hitbox-x);
      width:  49px;
      height: 25px;
      
      clip-path: path("M 2 0 l 39.5 0 q 7.5 0 7.5 11.5 q 0 11.5 -7.5 11.5 l -39 0 q -1.5 0 -1.5 -1 C 1 21 3 18.5 3 11.5 c 0 -7 -2 -9.5 -2 -10.5 Q 1 0 2.5 0 z");
      transform: scale(var(--scale, 1));
      transform-origin: left top;
   }
}
.next-ff {
   margin-right: calc(3px * var(--scale,1));
}
.prev-rw {
   margin-left: calc(3px * var(--scale,1));
}
.prev-rw {
   transform-box:    content-box;
   transform-origin: center center;
   transform:        scale(-100%, 100%);
}

/*
   The play/pause button separates its hitbox from its visuals using the same 
   tricks as the "previous" and "next" buttons.
*/
.play-pause {
   all: unset;
   appearance: none;
   user-select: none;
   color: transparent;
   
   --pull-adjacent-buttons-inward: -10px;
   
   grid-area: play;
   justify-self: center;
   
   width:     var(--play-pause-button-region);
   height:    0;
   margin:    0 var(--pull-adjacent-buttons-inward, 0px) calc(51px * var(--scale,1)) var(--pull-adjacent-buttons-inward, 0px);
   font-size: 0;
   position:  relative;
   
   &::before,
   &::after {
      content:  " ";
      display:  block;
      position: absolute;
      left:     0;
      top:      0;
   }
   
   --sprite: url(spritesheet-jewel.svg#normal);
   --glyph:  url(spritesheet-play-pause-labels.svg#play);
   
   &:hover {
      --sprite: url(spritesheet-jewel.svg#hover);
   }
   &:active {
      --sprite: url(spritesheet-jewel.svg#active);
   }
   &:disabled {
      --sprite: url(spritesheet-jewel.svg#disabled);
   }
   
   &::before { /* visuals */
      pointer-events: none;
      width:  var(--play-pause-button-region);
      height: var(--play-pause-button-region);
      
      background:
         var(--glyph)  left top/var(--play-pause-button-region) var(--play-pause-button-region) no-repeat,
         var(--sprite) left top/var(--play-pause-button-region) var(--play-pause-button-region) no-repeat
      ;
   }
   &::after { /* hitbox */
      --radius: calc(var(--play-pause-button-hitbox) / 2);
   
      width:     var(--play-pause-button-region);
      height:    var(--play-pause-button-region);
      clip-path: ellipse(var(--radius) var(--radius) at center center);
   }
}
:host(:state(playing)) .play-pause {
   --glyph: url(spritesheet-play-pause-labels.svg#pause) !important;
}

.volume {
   width: calc(67px * var(--scale,1));
   height: calc(30px * var(--scale,1));
   margin-left: calc(4px * var(--scale,1));
}